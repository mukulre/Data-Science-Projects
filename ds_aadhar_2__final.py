# -*- coding: utf-8 -*-
"""DS_Aadhar_2_ final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JIio97LoZ2hZDzfRPeyQBMgHutRTZBQU

Essential Libraries:

 The Seaborn theme to "darkgrid", which applies a grid-based dark background to all plots, enhancing visual clarity and making trends easier to spot in data visualizations.

Configuring Matplotlib to use a default figure size of 11 inches by 6 inches for all subsequent plots, ensuring consistency and readability in plot dimensions throughout the analysis.
"""

import pandas as pd # type: ignore
import matplotlib.pyplot as plt # type: ignore
import numpy as np # type: ignore
import seaborn as sns # type: ignore
from sklearn.ensemble import RandomForestRegressor # type: ignore
from sklearn.model_selection import train_test_split # type: ignore
from sklearn.preprocessing import LabelEncoder # type: ignore
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score # type: ignore

# Apply pandas and matplotlib settings for consistent visuals
sns.set_theme(style="darkgrid")
plt.rcParams["figure.figsize"] = (11, 6)

"""Data Import & Initial Processing

The code reads a CSV file, cleans column headers, ensures population columns are numeric (filling missing values with 0), and creates a total population column.

This results in reliable, consistent data ready for demographic analysis.
"""

# Ingest CSV file and tidy up column headers
df = pd.read_csv("/content/Demographic_update_data_March25.csv")
df.columns = [col.strip() for col in df.columns]

# Validate numeric formats and handle missing entries
df["Youth_5_17"] = pd.to_numeric(df["Demo_age_5_17"], errors="coerce").fillna(0)
df["Adult_17plus"] = pd.to_numeric(df["Demo_age_17+"], errors="coerce").fillna(0)

# Synthesize a column for collective population tally
df["Population_Total"] = df["Youth_5_17"] + df["Adult_17plus"]

"""Statewise Aggregation

The code aggregates population data by state, summing youth, adult, and total counts for each state.

It then calculates the proportion of the youth population within each state's total population as "Youth_Share".
"""

state_summary = (
    df.groupby("State")
      .agg({"Youth_5_17": "sum", "Adult_17plus": "sum", "Population_Total": "sum"})
      .reset_index()
)
state_summary["Youth_Share"] = state_summary["Youth_5_17"] / state_summary["Population_Total"]

"""Top States Visualization

The code selects the 10 states with the highest total populations and creates a bar plot to visualize them.

Y-axis labels are formatted for readability, showing population values as thousands ("K") or millions ("M") where appropriate.
"""

# Display largest states as per total residents
top_pop_states = state_summary.nlargest(10, "Population_Total")

def abbr_number(val):
    return f"{val/1e6:.1f}M" if val >= 1e6 else (f"{val/1e3:.1f}K" if val >= 1e3 else f"{val}")

plt.figure()
sns.barplot(
    data=top_pop_states,
    x="State", y="Population_Total", color="#0284C7"
)
plt.title("10 Most Populated States")
plt.xticks(rotation=40)
plt.ylabel("Population")
plt.gca().yaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: abbr_number(x)))
plt.tight_layout()
plt.show()

"""Stacked Bar Chart: Youth vs. Adults (Top 5 States)

The code creates a stacked bar chart showing the youth (ages 5–17) and adult (ages 17+) populations in the top five most populated states.

It visually separates these two age groups within each state, formatting population values for clarity.
"""

largest_5 = top_pop_states.head(5)
plt.figure()
plt.bar(largest_5["State"], largest_5["Youth_5_17"], label="Ages 5–17", color="#16A34A")
plt.bar(
    largest_5["State"], largest_5["Adult_17plus"],
    bottom=largest_5["Youth_5_17"], label="Ages 17+", color="#2563EB"
)
plt.legend()
plt.title("Age Distribution (Top 5 States)")
plt.ylabel("Residents")
plt.xticks(rotation=30)
plt.gca().yaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: abbr_number(x)))
plt.tight_layout()
plt.show()

"""Random Forest Regression: Predicting Adult Population

The code encodes state names as numerical values, trains a Random Forest model to predict the adult population (age 17+) using youth population and state as features, and evaluates the model.

Model performance metrics—MAE, MSE, and R²—are printed to assess prediction accuracy.
"""

# Encode categorical data for states
states_le = LabelEncoder()
df["State_Code"] = states_le.fit_transform(df["State"])

# Features and target definition
features = df[["Youth_5_17", "State_Code"]]
target = df["Adult_17plus"]

X_tr, X_te, y_tr, y_te = train_test_split(
    features, target, test_size=0.22, random_state=99
)
rf_mod = RandomForestRegressor(n_estimators=90, max_depth=4, random_state=99)
rf_mod.fit(X_tr, y_tr)
y_pred_rf = rf_mod.predict(X_te)

print("Random Forest Results:")
print(f"- MAE: {mean_absolute_error(y_te, y_pred_rf):.2f}")
print(f"- MSE: {mean_squared_error(y_te, y_pred_rf):.2f}")
print(f"- R2: {r2_score(y_te, y_pred_rf):.3f}")

"""Exploring Prediction Accuracy

The code computes the absolute prediction error between actual and predicted adult populations for all rows, identifying the entry with the largest discrepancy.

It then reports which state (and district, if available) had the strongest prediction deviation from the Random Forest model.
"""

df["Pred_Adults"] = rf_mod.predict(features)
df["RF_Error"] = np.abs(df["Adult_17plus"] - df["Pred_Adults"])
max_error_row = df.loc[df["RF_Error"].idxmax()]

print(
    f"Strongest prediction deviation in: {max_error_row['State']} (District: {max_error_row.get('District', 'Unknown')})."
)

"""Visualization: Prediction Scatter & Feature Impact

The code first creates a scatter plot comparing actual versus predicted adult population values, showing the model’s accuracy—closer alignment to the diagonal indicates better predictions.

It then displays a horizontal bar chart of feature importances from the Random Forest model, highlighting which input (youth population or state code) contributed most to prediction accuracy.
"""

# Actual vs. predicted values
plt.scatter(y_te, y_pred_rf, alpha=0.6, c="#2563EB")
plt.plot([y_te.min(), y_te.max()], [y_te.min(), y_te.max()], 'grey', lw=2, linestyle="--")
plt.title("Predicted vs Actual Adult Population")
plt.xlabel("Real Value")
plt.ylabel("Model Output")
plt.tight_layout()
plt.show()

# Relative importance of input columns
importances = rf_mod.feature_importances_
plt.barh(["Youth_5_17", "State_Code"], importances, color="#14B8A6")
plt.title("Feature Significance (Random Forest)")
plt.xlabel("Impact Score")
plt.tight_layout()
plt.show()

"""Scatter Plot: Comparing Youth and Adult Populations by District

The code generates a scatter plot showing the relationship between youth (ages 5–17) and adult (ages 17+) populations for each district, using orange points with transparency for clarity.

Number formatting enhances readability, and the visual quickly highlights how most districts have more adults than youths, with notable exceptions where youth populations are comparatively higher.
"""

import matplotlib.pyplot as plt # type: ignore
import seaborn as sns # type: ignore

# Visualize how the populations of ages 5-17 and 17+ compare in each district
plt.figure(figsize=(10, 6))

# Plot each district as a point, with color and transparency for clarity
sns.scatterplot(
    data=df,
    x="Demo_age_5_17",
    y="Demo_age_17+",
    color="#EA580C",  # Orange tone for distinction
    alpha=0.6
)

plt.title("District Comparison: Ages 5-17 vs Ages 17+", fontsize=16)
plt.xlabel("Population (5–17 years)", fontsize=12)
plt.ylabel("Population (17+ years)", fontsize=12)

# Format the number display for better legibility
def nice_number(n, pos):
    if n >= 1_000_000:
        return f"{n/1_000_000:.1f}M"
    elif n >= 1_000:
        return f"{n/1_000:.1f}K"
    else:
        return str(int(n))

import matplotlib.ticker as mticker # type: ignore
plt.gca().xaxis.set_major_formatter(mticker.FuncFormatter(nice_number))
plt.gca().yaxis.set_major_formatter(mticker.FuncFormatter(nice_number))

plt.tight_layout()
plt.show()

print(
    "This chart helps you see how youth and adult populations stack up across different districts. Typically, you’ll notice adults outnumber younger people; a few exceptions might stand out, showing districts with a relatively larger slice of the youth group."
)

"""Pie Chart: Age Group Proportions

The code calculates the total youth (ages 5–17) and adult (ages 17+) populations, then displays their proportions using a pie chart.

This visualization highlights that adults make up the majority of the population, with the chart clearly comparing each group's share.
"""

# Tabulate totals for youth and adults
total_youth = df["Demo_age_5_17"].sum()
total_adult = df["Demo_age_17+"].sum()
sizes = [total_youth, total_adult]
labels = ["Ages 5-17", "Ages 17+"]

plt.figure(figsize=(8, 8))
plt.pie(
    sizes,
    labels=labels,
    autopct="%1.1f%%",
    colors=["#10B981", "#3B82F6"],
    startangle=90
)

plt.title("Proportions: Youth (5-17) vs. Adults (17+)", fontsize=16)
plt.tight_layout()
plt.show()

print(
    "This pie chart quickly shows what share of the total population is made up of children and teenagers versus adults. Unsurprisingly, adults make up the majority in this dataset."
)

"""Install and Import Packages for XGBoost

The code imports essential libraries for data processing, encoding, regression modeling with XGBoost, model validation, and evaluation.

This setup prepares the environment for building and assessing a machine learning regression pipeline using structured data.
"""

# If running in a fresh environment, uncomment the next line:
# !pip install pandas xgboost scikit-learn

import pandas as pd # type: ignore
import numpy as np # type: ignore
from sklearn.model_selection import train_test_split # type: ignore
from sklearn.preprocessing import LabelEncoder # type: ignore
from xgboost import XGBRegressor # type: ignore
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score # type: ignore

"""Data Loading and Preprocessing

The code removes any extra spaces from column names and ensures that age columns contain only numeric values, converting non-numeric entries to zero.

This step standardizes your DataFrame, preparing the data for accurate analysis and calculations.
"""

# Clean up column names and convert age columns to numbers
df.columns = df.columns.str.strip()
df['Demo_age_5_17'] = pd.to_numeric(df['Demo_age_5_17'], errors='coerce').fillna(0)
df['Demo_age_17+'] = pd.to_numeric(df['Demo_age_17+'], errors='coerce').fillna(0)

""" Encode Categorical State Data and Define Features and Target"""

# Assign numeric codes to each unique state
state_encoder = LabelEncoder()
df['State_num'] = state_encoder.fit_transform(df['State'])

# Specify model input (features) and target variable
features = df[['Demo_age_5_17', 'State_num']]
target = df['Demo_age_17+']

"""Train-Test Split"""

# Separate data for model training and performance evaluation
X_train, X_valid, y_train, y_valid = train_test_split(
    features, target, test_size=0.2, random_state=42
)

"""Build and Train Model"""

# Create and fit the XGBoost regression model
xgb_reg = XGBRegressor(
    n_estimators=100, learning_rate=0.1, max_depth=5, random_state=42
)
xgb_reg.fit(X_train, y_train)

"""Prediction and Evaluation

The code predicts adult (17+) populations on the validation set using the trained XGBoost regression model, then calculates standard evaluation metrics.

Results include formatted values for mean absolute error, mean squared error, and R² score, providing a concise summary of model accuracy in estimating the adult population based on youth counts and state information.
"""

# Predict using validation set
y_pred = xgb_reg.predict(X_valid)

# Calculate evaluation metrics
def pretty_number(val):
    if val >= 1_000_000:
        return f"{val/1_000_000:.1f}M"
    elif val >= 1_000:
        return f"{val/1_000:.1f}K"
    return str(int(val))

mae = mean_absolute_error(y_valid, y_pred)
mse = mean_squared_error(y_valid, y_pred)
r_squared = r2_score(y_valid, y_pred)

print("Model Results:")
print(f"Mean Absolute Error: {pretty_number(mae)}")
print(f"Mean Squared Error: {pretty_number(mse)}")
print(f"R^2 Score: {r_squared:.3f}")
print("This regression estimates the 17+ population using younger age group count and state info.")

"""Model Error Exploration

The code predicts adult (17+) population across the full dataset and calculates the absolute prediction error for each district.

It then identifies and prints which district and state had the highest prediction error, including the error value formatted for readability.
"""

# Add predictions and errors for the entire dataset
df['Pred_17plus'] = xgb_reg.predict(df[['Demo_age_5_17', 'State_num']])
df['abs_error'] = abs(df['Demo_age_17+'] - df['Pred_17plus'])

error_row = df.loc[df['abs_error'].idxmax()]

print(
    f"The district with the largest prediction gap is in {error_row['State']} "
    f"(District: {error_row.get('District', 'Not Recorded')}) with an error of {pretty_number(error_row['abs_error'])}."
)

"""Setup and Data Preparation - ARIMA and SARIMA

ARIMA models are used for forecasting time series data by capturing patterns and trends through autoregression, differencing, and moving averages, making them effective for non-seasonal data.

SARIMA extends ARIMA by incorporating seasonal components, enabling it to handle data with repeating seasonal patterns, which is essential when demographic or other time series data exhibit seasonality.
"""

# Install libraries if needed (run in terminal if required)
# pip install pandas statsmodels matplotlib seaborn

import pandas as pd # type: ignore
import numpy as np # type: ignore
import matplotlib.pyplot as plt # type: ignore
import seaborn as sns # type: ignore
from statsmodels.tsa.arima.model import ARIMA # type: ignore
from statsmodels.tsa.statespace.sarimax import SARIMAX  # type: ignore
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score   # type: ignore
from datetime import datetime # type: ignore
from dateutil.relativedelta import relativedelta # type: ignore

# Plot preferences
sns.set_theme(style="whitegrid")
plt.rcParams['figure.figsize'] = (10, 6)

# Load dataset, clean headers, ensure numeric age types
df = pd.read_csv('/content/Demographic_update_data_March25.csv')
df.columns = df.columns.str.strip()
df['Demo_age_5_17'] = pd.to_numeric(df['Demo_age_5_17'], errors='coerce').fillna(0)
df['Demo_age_17+'] = pd.to_numeric(df['Demo_age_17+'], errors='coerce').fillna(0)

# Aggregate by State for broader trends
by_state = df.groupby('State', as_index=False).sum(numeric_only=True)

"""Create Sample Monthly Series for Forecast Example

The code selects one state as an example and sets up a timeline of 15 months starting from January 2024.

It then smoothly interpolates the youth (5–17) and adult (17+) populations for this state across the timeline, creating a DataFrame of these hypothetical monthly demographic trends.
"""

# Select a specific state as a working example
target_row = by_state.iloc[0]
chosen_state = target_row['State']

# Build 15 months of hypothetical observations
months = 15
series_dates = [datetime(2024, 1, 1) + relativedelta(months=i) for i in range(months)]

# Smoothly interpolate both demographic groups over the time period
timeline_data = pd.DataFrame({
    'date': series_dates,
    'adults_17_plus': np.linspace(target_row['Demo_age_17+'] * 0.8, target_row['Demo_age_17+'], months),
    'youth_5_17': np.linspace(target_row['Demo_age_5_17'] * 0.8, target_row['Demo_age_5_17'], months)
})

"""Model Training/Test Splitting"""

# Partition into training and evaluation slices
train_part = timeline_data.iloc[:-3]
test_part = timeline_data.iloc[-3:]

y_train = train_part['adults_17_plus']
y_test = test_part['adults_17_plus']

# Add youth group as an exogenous variable (input feature)
X_train = train_part[['youth_5_17']]
X_test = test_part[['youth_5_17']]

""" Fit and Evaluate ARIMA"""

# Train ARIMA with explanatory co-variate
arima = ARIMA(y_train, exog=X_train, order=(1, 1, 1)).fit()
arima_forecast = arima.forecast(steps=len(y_test), exog=X_test)

arima_mae = mean_absolute_error(y_test, arima_forecast)
arima_mse = mean_squared_error(y_test, arima_forecast)
arima_r2 = r2_score(y_test, arima_forecast)

"""Fit and Evaluate SARIMA"""

# Run SARIMAX to capture seasonality patterns if any
sarima = SARIMAX(y_train, exog=X_train, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12)).fit(disp=False)
sarima_forecast = sarima.forecast(steps=len(y_test), exog=X_test)

sarima_mae = mean_absolute_error(y_test, sarima_forecast)
sarima_mse = mean_squared_error(y_test, sarima_forecast)
sarima_r2 = r2_score(y_test, sarima_forecast)

"""Actual vs. Model Predictions Over Time"""

def nice_format(num):
    if num >= 1_000_000:
        return f"{num/1_000_000:.1f}M"
    elif num >= 1_000:
        return f"{num/1_000:.1f}K"
    return str(int(num))

plt.figure(figsize=(12, 6))
plt.plot(test_part['date'], y_test, marker='o', color='#EF4444', label='Observed')
plt.plot(test_part['date'], arima_forecast, marker='s', color='#3B82F6', label='ARIMA')
plt.plot(test_part['date'], sarima_forecast, marker='^', color='#10B981', label='SARIMA')
plt.title(f'17+ Population: Observed vs. Forecasts ({chosen_state})')
plt.xlabel('Month')
plt.ylabel('Population')
plt.gca().yaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: nice_format(x)))
plt.legend()
plt.tight_layout()
plt.show()

"""Prediction Accuracy: Scatter Plot"""

plt.figure(figsize=(10, 6))
plt.scatter(y_test, arima_forecast, color='#3B82F6', alpha=0.7, label='ARIMA')
plt.scatter(y_test, sarima_forecast, color='#10B981', alpha=0.7, label='SARIMA')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
plt.title('Prediction Comparison: Actual vs. Estimated')
plt.xlabel('Observed 17+ Population')
plt.ylabel('Forecasted 17+ Population')
plt.gca().xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: nice_format(x)))
plt.gca().yaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: nice_format(x)))
plt.legend()
plt.tight_layout()
plt.show()

"""Model Performance Summary"""

print(f"ARIMA Results:\n MAE: {nice_format(arima_mae)} | MSE: {nice_format(arima_mse)} | R²: {arima_r2:.3f}")
print(f"SARIMA Results:\n MAE: {nice_format(sarima_mae)} | MSE: {nice_format(sarima_mse)} | R²: {sarima_r2:.3f}")

"""Summary



Demographic projections for planning schools, healthcare, and social programs.

Identifying regions that may need additional infrastructure based on predicted age composition changes.

Model validation and feature analysis to improve future predictions or highlight data quality issues.

1. Population Forecasts by Age Group
Total Youth and Adult Populations:
Forecast the population sizes of youth (ages 5–17) and adults (ages 17+) in chosen states or districts for upcoming months or years.

Growth Trends:
Extrapolate trends to estimate how population numbers will change over time, even if actual historical monthly data is limited.

2. Resource Planning and Strategic Applications
Education and Infrastructure Planning:
Use forecasts to anticipate demand for schools, healthcare, and other age-dependent services in advance.

Budgeting and Policy Adjustments:
Projected demographic shifts can guide resource allocation and long-term development policies.

3. Forecasted Proportions and Ratios
Youth Share vs. Adult Share:
Predict how the ratio of youth to adults might evolve in future periods, aiding policy makers in anticipating changing age structures.

District and State Comparisons:
Forecast differences in demographic ratios across regions for targeted interventions.
"""

